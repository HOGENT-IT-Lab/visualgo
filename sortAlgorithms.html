<!DOCTYPE html>
<html>
<head>
  <title>Algorithm Visualization</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.1.1/svg.min.js"></script>
  <script src="main.js"></script>
  <link rel="stylesheet" type="text/css" href="style.css">
  <link href='https://fonts.googleapis.com/css?family=Ubuntu' rel='stylesheet'>
</head>
<body>
  <input type="checkbox" id="active">
  <label for="active" class="menu-btn"><i class="fas fa-bars"></i></label>
  <div class="wrapper">
    <ul>
      <li><a href="#">Home</a></li>
      <li><a href="./sortAlgorithms.html">Sorting Algorithms</a></li>
      <li><a href="./graphAlgorithms.html">Graph Algorithms</a></li>
      <li><a href="./searchAlgorithms.html">Search Algorithms</a></li>
      <li><a href="#">About</a></li>
    </ul>
  </div>
  <h1>Visualization Algorithms</h1>
  <h2>Sorting Algorithms</h2>
  <section>
    <h3>Sort by Selection</h3>
    <p>The basic idea of sorting by selection can be simply summarized:<br><br>
      1.  Find the largest element and place it at the back.<br>
      2.  Sort the rest of the array. <br><br>
      We will now look at this in a little more detail. In the array to be sorted, look for the largest element. 
      If this element is not et at the back of the row, this element must be swapped with the element at the last place. 
      The largest element is now at the back of the row; that is the correct place for this element.  
      The (n-1) remaining elements of the array still need to be sorted. For the subrow a[0], . . . , a[n-2] we proceed in an analogous way. 
      The largest element in the row is determined and placed at the back, that is, at the (n-2)-th position. 
      This procedure is repeated on progressively shorter partial rows. The last time, the partial row will still consist of two elements.
      
      </p>
    <div id="sortBySelection"></div>
    <div class="icons">
      <img id="sortBySelectionBackward" src="./images/backward.svg" alt="slower">
      <img id="sortBySelectionPlay" src="./images/play.svg" alt="play" style="display: inline;">
      <img id="sortBySelectionPause" src="./images/pause.svg" alt="pause" style="display: none;">
      <img id="sortBySelectionForward" src="./images/forward.svg" alt="faster">
    </div>
    <h3>Sort by Insertion</h3>
    <p>The basic idea behind sorting by insertion can be summarized as follows:<br><br>
      1.  Suppose there is already a part at the front of the array sorted.<br>
      2.  Take the first element of the unsorted part and insert this element at the 
        appropriate place in the sorted part. In this way, the sorted part is expanded. <br><br>
      In other words, sorting by insertion or "card sort" is best compared to putting cards in order. 
      We start with the second card.  We see if it should come before the first or not. 
      Then we take the next card and immediately place it in the correct position relative to the previous cards. 
      We continue this way until all the cards are in the correct position. 
      In the algorithm this is: if the first i elements are already sorted then we are going to look at 
      the (i+1)-st element. This element is inserted in the correct place. If necessary, 
      the already sorted larger elements all have to advance one position.

      </p>
    <div id="sortByInsertion"></div>
    <div class="icons">
      <img id="sortByInsertionBackward" src="./images/backward.svg" alt="slower">
      <img id="sortByInsertionPlay" src="./images/play.svg" alt="play" style="display: inline;">
      <img id="sortByInsertionPause" src="./images/pause.svg" alt="pause" style="display: none;">
      <img id="sortByInsertionForward" src="./images/forward.svg" alt="faster">
    </div>
    <h3>Merge Sort</h3>
    <p>
      Sorting by blending (mergesort) is a more complicated algorithm than the previous two simple sorting algorithms 
      but is also quite a bit more efficient. <br>
      The basic idea is as follows:<br><br>
      1.  Sort the first half of the array.<br>
      2.  Sort the second half of the array.<br>
      3.  Blend the two sorted partial rows together into one sorted array.<br><br>
      The first two steps in this process are done in a recursive manner.
    </p>
    <div id="mergeSort"></div>
    <div class="icons">
      <img id="mergeSortBackward" src="./images/backward.svg" alt="slower">
      <img id="mergeSortPlay" src="./images/play.svg" alt="play" style="display: inline;">
      <img id="mergeSortPause" src="./images/pause.svg" alt="pause" style="display: none;">
      <img id="mergeSortForward" src="./images/forward.svg" alt="faster">
    </div>
    <h3>Bubble Sort</h3>
    <p>
      Bubble sort is a basic algorithm for arranging a string of numbers or other elements in the correct order. 
      The method works by examining each set of adjacent elements in the string, from left to right, 
      switching their positions if they are out of order. The algorithm then repeats this process until it 
      can run through the entire string and find no two elements that need to be swapped.
    </p>
    <div id="bubbleSort"></div>
    <div class="icons">
      <img id="bubbleSortBackward" src="./images/backward.svg" alt="slower">
      <img id="bubbleSortPlay" src="./images/play.svg" alt="play" style="display: inline;">
      <img id="bubbleSortPause" src="./images/pause.svg" alt="pause" style="display: none;">
      <img id="bubbleSortForward" src="./images/forward.svg" alt="faster">
    </div>
  </section>
  <footer>Website by Maxime Coens and Thomas Louage (<a href="https://www.hogent.be/">@Hogeschool Gent</a>)</footer>
</body>
</html>